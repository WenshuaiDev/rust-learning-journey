# 刚开始用 Rust 时，我为什么觉得模块系统特别乱

这是我开始写 Rust 项目后，第一个让我非常不适应的地方。

不是所有权，也不是生命周期，  
而是：**模块怎么组织，我完全没概念。**

## 1. 我最直接的感受：Rust 的模块用起来很别扭

在 Go 里，我几乎不用“学模块系统”：

- 一个文件就是一个 package
- 用就直接 import
- 不用提前声明
- 不太会思考“这个东西该不该暴露”

但在 Rust 里，我一上来就被这些东西搞懵了：

- `mod`
- `pub`
- 文件名和模块名的对应关系
- 有的东西明明写了，但就是用不了

最真实的感受是：

> **我只是想引用一个代码，为什么要想这么多？**

## 2. 第一个让我崩溃的点：为什么要先 `mod` 才能用？

我一开始的理解是：

> 文件在那儿，不就应该能 import 吗？

但 Rust 不是这样。

哪怕你已经有了：

```text
src/
├── main.rs
└── foo.rs
```
如果你在 main.rs 里直接用 foo，**编译器会告诉你：找不到这个模块**。

我后来才意识到：
- Rust 不会自动加载文件
- 每一个模块，都必须被显式声明
- mod foo; 这行代码，本质是在说：
    > “这个模块，属于我这个 crate”

这一步在 Go 里是完全不存在的。

## 3. *pub* 让我第一次意识到：默认是“不给你用”的
第二个非常反直觉的地方是：**默认私有**。

在 Rust 里：
- struct 默认不能跨模块用
- 函数默认不能用
- 字段默认也不能用

我一开始的应对方式非常粗暴：

```Rust
pub struct Xxx {
    pub a: i32,
    pub b: i32,
}
```


结果就是：
- pub 到处都是
- 我自己都不知道哪些是“真的需要暴露的”

但在那个阶段，我**根本没能力设计边界**，只是为了让代码先跑起来。

## 4. 最坑我的一个点：`main.rs` 和 `lib.rs` 同名，但不是一个 `crate`
这是我觉得最容易被忽略、但又非常关键的一点。
一开始我以为：
>main.rs 和 lib.rs 都在同一个项目里，
那它们应该是同一个 crate 的不同入口？

事实是：
- `main.rs` → 一个 `binary crate`
- `lib.rs` → 一个 `library crate`
- 就算包名一样，它们依然是 两个不同的 `crate`

这直接导致我一开始非常困惑：
- 为什么我在`lib.rs`里定义的模块，在`main.rs`里用不了？
- 为什么有时候要`use my_crate::xxx`，有时候又不用？
- 为什么模块路径看起来这么怪？

后来我才搞清楚一件事：
>main.rs 不能“天然访问” lib.rs 的内容，
它只是 依赖 了这个库 crate。

这个认知，对我后面理解 Rust 项目结构非常关键。

## 5. 我现在对 Rust 模块系统的最低接受版本理解

到目前为止，我给自己一个不再焦虑的最低标准：
- Rust 的模块不是为了“方便用”
- 而是为了明确**代码属于谁**

所有东西：

- 要么属于某个模块
- 要么就不该被外部用

我现在不再追求：

- 一开始就拆得很好

- 模块层级很优雅

而是先做到：

- 我知道代码为什么用不了

- 我知道是 mod 还是 pub 的问题

- 我知道 main 和 lib 根本不是一回事

这已经比一开始瞎猜，要好很多了。

---

← [回到索引](../README.md)